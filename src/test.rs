//! Documentation tests.

use std::io::prelude::*;
use std::process::{Command, Output, Stdio};

use pulldown_cmark::{Event, Parser, Tag};
use quote::{ToTokens, Tokens};
use serde_json::{self, Value};
use syn::{self, Block, Constness, FnDecl, FunctionRetTy, Generics, Ident, Item, ItemKind, Stmt,
          Unsafety, Visibility, WhereClause};
use tempdir::TempDir;

use Config;
use Result;
use json::Document;

/// The outcome of a documentation test.
pub enum TestResult {
    /// The test passed.
    Success,

    /// The test failed. Includes output generated by the failure.
    Failure(Output),
}

/// Find and prepare tests in the given document.
pub fn gather_tests(document: &Document) -> Vec<String> {
    if let Some(docs) = document.attributes.get("docs") {
        find_test_blocks(docs)
            .into_iter()
            .map(|block| {
                let crate_name = document.id.split("::").next().unwrap();
                preprocess(&block, crate_name)
            })
            .collect()
    } else {
        vec![]
    }
}

/// Returns the testable code blocks in a given markdown string.
///
/// Any formatting in the code blocks (`#`) will be removed.
fn find_test_blocks(docs: &str) -> Vec<String> {
    let mut tests = vec![];

    let mut parser = Parser::new(docs);

    while let Some(event) = parser.next() {
        match event {
            Event::Start(Tag::CodeBlock(ref language))
                if language.is_empty() || language == "rust" =>
            {
                let mut test = String::new();
                while let Some(event) = parser.next() {
                    match event {
                        Event::End(Tag::CodeBlock(_)) => {
                            tests.push(test);
                            break;
                        }
                        Event::Text(ref line) => {
                            let line = line.trim();
                            let trimmed_line = if line.starts_with("##") {
                                &line[1..]
                            } else if line.starts_with("# ") {
                                &line[2..]
                            } else {
                                line
                            };
                            test.push_str(trimmed_line);
                        }
                        _ => (),
                    }
                }
            }
            _ => (),
        }
    }

    tests
}

/// Preprocess a test for later compilation and execution.
///
/// 1. First, inject the current crate as an `extern crate` if no `extern crate`s are present.
/// 2. Wrap the code in `fn main() {}` if there is no `main` function.
///
/// Any crate attributes are preserved at the top level.
fn preprocess(test: &str, crate_name: &str) -> String {
    if let Ok(mut test_crate) = syn::parse_crate(test) {
        let has_extern_crate = test_crate.items.iter().any(|item| match item.node {
            ItemKind::ExternCrate(..) => true,
            _ => false,
        });

        let has_main_function = test_crate.items.iter().any(|item| match item.node {
            ItemKind::Fn(..) if item.ident == "main" => true,
            _ => false,
        });

        if !has_main_function {
            let new_main = ItemKind::Fn(
                Box::new(FnDecl {
                    inputs: vec![],
                    output: FunctionRetTy::Default,
                    variadic: false,
                }),
                Unsafety::Normal,
                Constness::NotConst,
                None,
                Generics {
                    lifetimes: vec![],
                    ty_params: vec![],
                    where_clause: WhereClause::none(),
                },
                Box::new(Block {
                    stmts: test_crate
                        .items
                        .drain(..)
                        .map(|item| Stmt::Item(Box::new(item)))
                        .collect(),
                }),
            );

            test_crate.items.push(Item {
                ident: Ident::new("main"),
                vis: Visibility::Inherited,
                attrs: vec![],
                node: new_main,
            });
        }

        // TODO: Handle `#![doc(test(no_crate_inject))]`?
        if !has_extern_crate && crate_name != "std" {
            test_crate.items.insert(
                0,
                Item {
                    ident: Ident::new(crate_name),
                    vis: Visibility::Inherited,
                    attrs: vec![],
                    node: ItemKind::ExternCrate(None),
                },
            )
        }

        let mut tokens = Tokens::new();
        test_crate.to_tokens(&mut tokens);
        let program = tokens.to_string();

        program
    } else {
        // If we couldn't parse the crate, then test compilation will fail anyways. Just wrap
        // everything in a main function.
        format!("fn main() {{\n{}\n}}", test)
    }
}

/// Execute a test.
pub fn run_test(config: &Config, program: &str) -> Result<TestResult> {
    static TEST_NAME: &str = "rustdoc-test";

    // First, determine the location of the dependency artifacts so we can pass them to rustc.
    let output = Command::new("cargo")
        .arg("build")
        .arg("--manifest-path")
        .arg(&config.manifest_path)
        .args(&["--message-format", "json"])
        .output()?;
    if !output.status.success() {
        return Err(format_err!(
            "cargo did not exit successfully: {}",
            output.status
        ));
    }

    let output = String::from_utf8(output.stdout).expect("cargo did not output valid utf-8");

    let mut externs = vec![];

    for message in output.lines() {
        let message = serde_json::from_str::<Value>(message)?;
        let is_compiler_artifact = message
            .as_object()
            .unwrap()
            .get("reason")
            .and_then(Value::as_str)
            .map(|reason| reason == "compiler-artifact")
            .unwrap_or_default();

        if is_compiler_artifact {
            let name = message
                .pointer("/target/name")
                .and_then(Value::as_str)
                .unwrap();
            let rlib = message
                .pointer("/filenames/0")
                .and_then(Value::as_str)
                .unwrap();

            externs.push(format!("{}={}", name, rlib));
        }
    }

    let extern_args: Vec<_> = externs
        .into_iter()
        .flat_map(|arg| vec![String::from("--extern"), arg])
        .collect();

    let tempdir = TempDir::new("rustdoc")?;

    // Compile the test.
    //
    // TODO: If the tests fail, the output we get will not include the name of the file that the
    // test came from, since we're passing the code through stdin.
    let mut rustc = Command::new("rustc")
        .arg("-")
        .args(&["-o", TEST_NAME])
        .args(&["--cap-lints", "allow"])
        .args(extern_args)
        .current_dir(&tempdir)
        .stderr(Stdio::piped())
        .stdin(Stdio::piped())
        .spawn()?;

    rustc.stdin.as_mut().unwrap().write_all(program.as_bytes())?;

    let rustc_output = rustc.wait_with_output()?;
    if !rustc_output.status.success() {
        return Ok(TestResult::Failure(rustc_output));
    }

    // Run the test.
    let test_output = Command::new(tempdir.as_ref().join(TEST_NAME))
        .current_dir(&tempdir)
        .output()?;

    let result = if test_output.status.success() {
        TestResult::Success
    } else {
        TestResult::Failure(test_output)
    };

    Ok(result)
}

#[cfg(test)]
mod tests {
    #[test]
    fn find_test_blocks() {
        let docs = indoc!(
            r#"
            Documentation example.

            ```
            assert!(true);
            ```

            A code example.

            ```c
            printf("Hello, world!\n");
            ```

            Another documentation example.

            ```rust
            assert_eq!(1 + 1, 2);
            ```
            "#
        );

        let tests = super::find_test_blocks(docs);
        assert_eq!(tests.len(), 2);

        let hidden_import = indoc!(
            r#"
            ```
            # use example::Example;
            ```
            "#
        );
        assert!(!super::find_test_blocks(hidden_import)[0].contains("#"));
    }

    #[test]
    fn preprocess() {
        assert!(!super::preprocess("not rust code", "some_crate").is_empty());

        assert_eq!(
            &super::preprocess("assert!(true);", "test_crate"),
            quote!{
                extern crate test_crate;
                fn main() {
                    assert!(true);
                }
            }.as_str()
        );

        assert_eq!(
            &super::preprocess(
                indoc!(
                    r#"
                        extern crate rustdoc;
                        use rustdoc::build;
                    "#
                ),
                "some_other_crate",
            ),
            quote!{
                fn main() {
                    extern crate rustdoc;
                    use rustdoc::build;
                }
            }.as_str()
        );

        assert_eq!(
            &super::preprocess(
                indoc!(
                    r#"
                        fn main() { println!("Hello, world!"); }
                    "#
                ),
                "hello_world",
            ),
            quote!{
                extern crate hello_world;
                fn main() {
                    println!("Hello, world!");
                }
            }.as_str()
        );
    }
}
